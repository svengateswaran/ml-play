<html>

<head>
<style>
body {
margin:0px;
}
</style>
</head>

<body>

  <script src="threejs/three.min.js"></script>
  <script src="threejs/OrbitControls.js"></script>
  <script src="threejs/CanvasRenderer.js"></script>
  <script src="threejs/Projector.js"></script>

  <script>

	var mouseX = 0, mouseY = 0,
	windowHalfX = window.innerWidth / 2,
	windowHalfY = window.innerHeight / 2,
	SEPARATION = 200,
	AMOUNTX = 10,
	AMOUNTY = 10,
	camera, scene, renderer;
        show_all = 0;
	init();
	animate();


        function draw_layer(scene, material, index, ih, iw, oh, ow, kh, kw, c, f) {

                neuron_size = 5;
                neuron_spacing = 20;
                channel_spacing = 10;
                layer_spacing = 500;

            
                var pad_h = Math.floor(kh / 2);
                var pad_w = Math.floor(kw / 2);
                if(oh == 1 && ow  == 1) {
                  pad_h = 0;
                  pad_w = 0;
                } 
                  
		for ( var i = 0; i < oh; i++ ) {
  		  for ( var j = 0; j < ow; j++ ) {
		    for ( var k = 0; k < f; k++ ) {

                        var particle = new THREE.Sprite(material);
			particle.position.x = k * (oh*(neuron_spacing+neuron_size) + channel_spacing) + (i * neuron_spacing);
			particle.position.y = j * neuron_spacing;
		        particle.position.z = index * layer_spacing;
			particle.scale.x = particle.scale.y = neuron_size;
			scene.add(particle);
                       
                        var l_color = 0xffcc00;
                         
                        if (show_all || (i == Math.floor(ow/2) && j == Math.floor(oh/2) && k == Math.floor(f/2))) {

                        if (index > 0) {
                            for (var ki = 0; ki < kh; ki++) {
                              for (var kj = 0; kj < kw; kj++) {
                                for (var kc = 0; kc < c; kc++) {

                                  var lix = i + ki - pad_h;
                                  var liy = j + kj - pad_w;
                                  var ix = kc * (ih* (neuron_spacing + neuron_size) + channel_spacing) + lix * neuron_spacing;
                                  var iy = liy * neuron_spacing;
                                  var iz = (index - 1) * layer_spacing;
                                  if (lix >= 0 && lix < iw && liy >= 0 && liy < ih) {
                                      var geometry = new THREE.Geometry();
                     		      geometry.vertices.push(particle.position);
     	                	      geometry.vertices.push(new THREE.Vector3( ix, iy, iz ));
                                      var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: l_color, opacity: 1 } ) );
                	              scene.add(line);
                                  }
                                }
                              }
                            }
                          }
                        }
                    }
                  }
                }

        }

	function init() {
		var container, separation = 100, amountX = 50, amountY = 50,
		particles, particle;
		container = document.createElement('div');
		document.body.appendChild(container);
		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.z = 1000;
		scene = new THREE.Scene();
		renderer = new THREE.CanvasRenderer();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );

                var controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.rotateSpeed = 0.8;



		// particles
		var PI2 = Math.PI * 2;
		var material = new THREE.SpriteCanvasMaterial( {
			color: 0xffffff,
			program: function ( context ) {
				context.beginPath();
				context.arc( 0, 0, 0.5, 0, PI2, true );
				context.fill();
			}
		} );
		var geometry = new THREE.Geometry();
              
               
                
                var h = 10, w = 10;
                var kh = 3, kw = 3;
                in_c = 3;
                var fc = 32;
                var outputs = 2;
                  
               /* 
                var h = 48, w = 48;
                var kh = 3, kw = 3;
                in_c = 1;
                var fc = 64;
                var outputs = 10;
                */
             
                /* Build a simple CNN */
                draw_layer(scene, material, 0, h, w, h, w, kh, kw, 0, in_c);
                draw_layer(scene, material, 1, h, w, h, w, kh, kw, in_c, 2);
                draw_layer(scene, material, 2, h, w, h, w, kh, kw, 2, 3);
                draw_layer(scene, material, 3, h, w, 1, 1, h, w, 3, fc);
                draw_layer(scene, material, 4, 1, 1, 1, 1, 1, 1, fc, outputs);
	}


	function animate() {
		requestAnimationFrame( animate );
		render();
	}
	function render() {
		renderer.render( scene, camera );
	}

        function toggle_data() {
           if(show_all == 1)
             show_all = 0;
           else
             show_all = 1;
           animate();
        }

  </script>

<!---  <button class="toggle-data-btn" onClick="toggle_data()">Show me something else</button> --->
</body>
</html>
